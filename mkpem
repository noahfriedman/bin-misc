#!/usr/bin/env bash
# $Id: mkpem,v 1.14 2016/07/11 23:41:40 friedman Exp $

# Commentary:

# Example config.dn for an SSL server certificate:
#
#     C              = US
#     ST             = California
#     L              = San Francisco
#     O              = Nocturnal Aviation, Inc.
#     OU             = Shipping and Receiving
#     CN             = foo.bar.com
#
#     [ v3_ca ]
#     subjectAltName = @alt_names
#
#     [ alt_names ]
#     DNS.01         = cname.bar.com
#     DNS.02         = othercname.bar.com
#     IP.01          = 127.0.0.1
#     IP.02          = ::1
#     email.01       = foo@bar.com
#
# Order is least significant to most significant!
# Usually you want to list C first and CN last.
#
# The v3_ca and alt_names sections are optional.

# To import a web cert into a NSS database:
#
#	certutil -d [sql|dbm]:[/dir] -A -n [nickname] -t P -i [file.crt]
#
# Use -t CT,C,C for CA certificates.

# Code:

# Return the next emacs-style backup file name for a given file on disk,
# based on the VERSION_CONTROL environment variable.
# `t' or `numbered' means make numeric backup versions unconditionally.
# `nil' or `existing' means make them for files that have some already.
# `never' or `simple' means do not make them.
make_backup_file_name()
{
    local name=$1
    shift

    case $VERSION_CONTROL in
        never | simple ) result=$name~ ;;
        * )
            highest=$(for f in "$name".~*~ ; do echo "$f"; done \
                      | sed -ne 's/~$//' -e 's/.*\.~//' -e p \
                      | sort -nr \
                      | head -1)
            case $highest in
                '*' | '' ) highest=0 ;;
            esac
            case $VERSION_CONTROL in
                nil | existing )
                    case $highest in
                        0 ) result=$name~ ;;
                    esac ;;
                t | numbered | * )
                    next=$(( $highest + 1 ))
                    result=$name.~$next~ ;;
            esac ;;
    esac

    echo "$result"
}

mkpem()
{
    local config=$1
    local base=$2
    shift; shift

    local pem=$base.pem
    local crt=$base.crt
    local key=$base.key

    local ksz=${MKPEM_KEYSIZE:-4096}
    local yrs=${MKPEM_YEARS:-10}
    local  sn=${MKPEM_SERIAL:-`TZ=UTC date +"$datefmt"`}

    local days=$(( 365 * $yrs ))

    for f in $pem $crt $key ; do
        if [[ -f $f ]]; then
            bck=`make_backup_file_name "$f"`
            echo "Moving existing $f -> $bck"
            mv "$f" "$bck"
        fi
    done

    {
        echo "[ req ]"
        echo RANDFILE                = /dev/urandom
        echo prompt                  = no
        echo x509_extensions         = v3_ca
        echo distinguished_name      = req_dn
        echo default_bits            = $ksz
        echo default_md              = sha256
        echo utf8                    = yes
        echo string_mask             = utf8only

        echo
        echo "[ v3_ca ]"
        echo  subjectKeyIdentifier   = hash
        echo  authorityKeyIdentifier = keyid:always, issuer:always

        # Critical means cert should be rejected when used for purposes other
        # than those indicated in this extension.
        #
        # Settings for CA cert
        #echo basicConstraints       = critical, CA:true, pathlen:0
        #echo keyUsage               = critical, digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment, keyAgreement, keyCertSign, cRLSign, encipherOnly, decipherOnly
        #echo extendedKeyUsage       = critical, serverAuth, clientAuth, codeSigning, emailProtection, timeStamping, msSGC, nsSGC

        # Settings for basic self-signed web server cert
        echo basicConstraints        = CA:false
        echo keyUsage                = digitalSignature, keyEncipherment, keyCertSign
        echo extendedKeyUsage        = serverAuth

        # Don't use nsCertType; deprecated.
        #echo nsCertType             = critical, sslCA, emailCA, client, server, email, objsign
        #echo nsCertType             = critical, server

        echo
        echo "[ req_dn ]"
        while read l; do echo "$l" ; done < $config
    } | openssl req \
                -config     /dev/stdin  \
                -x509                   \
                -newkey     rsa         \
                -nodes                  \
                -set_serial $sn         \
                -days       $days       \
                -keyout     "$key"      \
                -out        "$crt"      \
                "$@"

    {   echo
        openssl x509 -in "$crt" -noout -text
    } >> "$crt"

    cat "$key" "$crt" > "$pem"
}

main()
{
  umask 077

  case $# in
    0 ) echo $"Usage: `basename $0` configfile.dn" 1>&2
        exit 1 ;;
  esac

  datefmt='%Y%m%d%H%M%S'
  if date --help 2>&1 | grep nanoseconds > /dev/null ; then
      datefmt=$datefmt'%N'
  fi

  config=$1
  shift
  basename=`basename $config .dn`
  mkpem "$config" "$basename" "$@"
}

main "$@"

# eof

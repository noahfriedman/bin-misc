#!/usr/bin/env bash
# $Id: mkpem,v 1.15 2016/07/12 00:52:58 friedman Exp $

# Commentary:

# Example config.dn for an SSL server certificate:
#
#     C              = US
#     ST             = California
#     L              = San Francisco
#     O              = Nocturnal Aviation, Inc.
#     OU             = Shipping and Receiving
#     CN             = foo.bar.com
#
#     [ v3_ca ]
#     subjectAltName = @alt_names
#
#     [ alt_names ]
#     DNS.01         = cname.bar.com
#     DNS.02         = othercname.bar.com
#     IP.01          = 127.0.0.1
#     IP.02          = ::1
#     email.01       = foo@bar.com
#
# Order is least significant to most significant!
# Usually you want to list C first and CN last.
#
# The v3_ca and alt_names sections are optional.

# To import a web cert into a NSS database:
#
#	certutil -d [sql|dbm]:[/dir] -A -n [nickname] -t P -i [file.crt]
#
# Use -t CT,C,C for CA certificates.

# Code:

# Return the next emacs-style backup file name for a given file on disk,
# based on the VERSION_CONTROL environment variable.
# `t' or `numbered' means make numeric backup versions unconditionally.
# `nil' or `existing' means make them for files that have some already.
# `never' or `simple' means do not make them.
make_backup_file_name()
{
    local name=$1
    shift

    case $VERSION_CONTROL in
        never | simple ) result=$name~ ;;
        * )
            highest=$(for f in "$name".~*~ ; do echo "$f"; done \
                      | sed -ne 's/~$//' -e 's/.*\.~//' -e p \
                      | sort -nr \
                      | head -1)
            case $highest in
                '*' | '' ) highest=0 ;;
            esac
            case $VERSION_CONTROL in
                nil | existing )
                    case $highest in
                        0 ) result=$name~ ;;
                    esac ;;
                t | numbered | * )
                    next=$(( $highest + 1 ))
                    result=$name.~$next~ ;;
            esac ;;
    esac

    echo "$result"
}

backup_files()
{
    for f in "$@"; do
        if [ -f "$f" ]; then
            bck=`make_backup_file_name "$f"`
            echo "Moving existing $f -> $bck"
            mv "$f" "$bck"
        fi
    done
}

printconf()
{
    echo "[ req ]"
    echo RANDFILE                = /dev/urandom
    echo prompt                  = no
    echo x509_extensions         = v3_ca
    echo req_extensions          = v3_ca
    echo distinguished_name      = req_dn
    echo default_bits            = ${MKPEM_KEYSIZE:-4096}
    echo default_md              = sha256
    echo utf8                    = yes
    echo string_mask             = utf8only

    echo
    echo "[ v3_ca ]"
    echo  subjectKeyIdentifier   = hash

    # Critical means cert should be rejected when used for purposes other
    # than those indicated in this extension.
    #
    # Settings for CA cert
    #echo basicConstraints       = critical, CA:true, pathlen:0
    #echo keyUsage               = critical, digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment, keyAgreement, keyCertSign, cRLSign, encipherOnly, decipherOnly
    #echo extendedKeyUsage       = critical, serverAuth, clientAuth, codeSigning, emailProtection, timeStamping, msSGC, nsSGC

    # Settings for basic self-signed web server cert
    echo basicConstraints        = CA:false
    echo keyUsage                = digitalSignature, keyEncipherment, keyCertSign
    echo extendedKeyUsage        = serverAuth

    # Don't use nsCertType; deprecated.
    #echo nsCertType             = critical, sslCA, emailCA, client, server, email, objsign
    #echo nsCertType             = critical, server

    echo
    echo "[ req_dn ]"
    while read l; do echo "$l" ; done < $1
}

mkpem()
{
    local config=$1
    local base=$2
    shift; shift

    local pem=$base.pem
    local crt=$base.crt
    local key=$base.key

    local yrs=${MKPEM_YEARS:-10}
    local  sn=${MKPEM_SERIAL:-`TZ=UTC date +"$datefmt"`}

    local days=$(( 365 * $yrs ))

    backup_files "$pem" "$crt" "$key"

    {
        printconf "$config"
        # This cannot be specified for CSRs, so add it here:
        echo "[ v3_ca ]"
        echo "authorityKeyIdentifier = keyid:always, issuer:always"
    } \
        | openssl req \
                  -config     /dev/stdin  \
                  -batch                  \
                  -x509                   \
                  -newkey     rsa         \
                  -nodes                  \
                  -set_serial $sn         \
                  -days       $days       \
                  -keyout     "$key"      \
                  -out        "$crt"      \
                  "$@"

    {   echo
        openssl x509 -in "$crt" -noout -text \
                -nameopt RFC2253 \
                -certopt ext_parse
    } >> "$crt"

    cat "$key" "$crt" > "$pem"
}

mkcsr()
{
    local config=$1
    local base=$2
    shift; shift

    backup_files "$base.key" "$base.csr"

    printconf "$config" \
        | openssl req \
                  -config     /dev/stdin   \
                  -batch                   \
                  -new                     \
                  -newkey     rsa          \
                  -nodes                   \
                  -keyout     "$base.key"  \
                  -out        "$base.csr"  \
                  "$@"

    {   echo
        openssl req -in "$base.csr" -text -verify -noout \
                -nameopt RFC2253 \
                -reqopt  ext_parse
    } >> "$base.csr"
}

main()
{
  umask 077

  op=pem
  case $1 in
      csr | -csr | --csr ) op=csr ; shift ;;
  esac

  case $# in
    0 ) echo $"Usage: `basename $0` configfile.dn" 1>&2
        exit 1 ;;
  esac

  datefmt='%Y%m%d%H%M%S'
  if date --help 2>&1 | grep nanoseconds > /dev/null ; then
      datefmt=$datefmt'%N'
  fi

  config=$1
  shift
  basename=`basename "$config" .dn`
  mk$op "$config" "$basename" "$@"
}

main "$@"

# eof

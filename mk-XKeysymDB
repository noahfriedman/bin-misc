#!/usr/bin/env perl

use strict;
use warnings qw(all);

use Getopt::Long;
use Pod::Usage;
use POSIX    qw(strftime uname);

my %opt = ( annotate => 0 );

my @header  = (qw( keysymdef.h
                   ap_keysym.h
                   DECkeysym.h
                   HPkeysym.h
                   Sunkeysym.h
                   XF86keysym.h ));

my @include = (qw( /usr/include/X11
                   /usr/X11R6/include/X11
                   /usr/local/include/X11 ));

my @found_headers;

sub parse_headers
{
  my ($fh, $tbl) = @_;
  my %collide;

  return unless $fh;
  while (<$fh>)
    {
      if (m=^#define\s+(.*)XK_([\da-z_]+)\s+0x([\da-f]+)\s*(?:/\*\s*\(?(.*?)\)?\s*\*/|(.*))=i)
        {
          $tbl->{$1 . $2} = { keycode => $3,
                              desc    => $4,
                            };
        }
    }
}

sub sort_keysyms_pred
{
  my ($tbl, $a, $b) = @_;

  ((hex( $tbl->{$a}->{keycode} ) <=> hex( $tbl->{$b}->{keycode} ))
   || (lc( $a ) cmp lc( $b ))
   || (    $a   cmp     $b ));
}

sub display
{
  my ($tbl) = @_;

  #if (! -t STDOUT)
    {
      (my $progname = $0) =~ s=.*/==;
      my $hostname  = (uname())[1];
      my $timestr   = strftime( '%Y-%m-%d', localtime( time ));

      my $fmt    = "\nGenerated by %s %s \@%s\nfrom the following headers:\n\n";
      my $banner = sprintf( $fmt, $progname, $timestr, $hostname );
      $banner =~ s/^/! /gm;

      print( "! XKeysymDB\n", $banner );
      map { printf( "!\t%s\n", $_ ) } @found_headers;
      print( "\n" );
    }

  for my $sym (sort { sort_keysyms_pred( $tbl, $a, $b ) } keys %$tbl)
    {
      my $elt = $tbl->{$sym};
      if ($elt->{desc} && $opt{annotate})
        {
          printf( "%-30s\t:%-8s\t! %s\n", $sym, uc( $elt->{keycode} ), $elt->{desc} );
        }
      else
        {
          printf( "%-30s\t:%s\n", $sym, uc( $elt->{keycode} ));
        }
    }
}

sub open_header
{
  my $header = shift;
  my $fh;

  map { if (open( $fh, "$_/$header" ))
          {
            push @found_headers, "$_/$header";
            return $fh;
          }
      } @include;
}

sub parse_options
{
  my $help = -1;
  local *ARGV = \@{$_[0]}; # modify our local arglist, not real ARGV.

  my $parser = Getopt::Long::Parser->new;
  $parser->configure (qw(bundling autoabbrev no_ignore_case));
  my $succ = $parser->getoptions
    ( "h|?|help+"   => \$help,

      "a|annotate!" => \$opt{annotate},
      "A"           => sub { $opt{annotate} = 0 },
    );

  pod2usage (-exitstatus => 1, -verbose => 0)     unless $succ;
  pod2usage (-exitstatus => 0, -verbose => $help) if $help >= 0;
}

sub main
{
  parse_options (\@_);

  my %tbl;
  map { parse_headers( open_header( $_ ), \%tbl ) } @header;
  display( \%tbl );
}

main( @ARGV );

# eof
